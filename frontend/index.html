<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirDrop P2P</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        :root { --primary: #007bff; --success: #28a745; --danger: #dc3545; --bg: #f8f9fa; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); padding: 20px; color: #333; display: flex; justify-content: center; }
        .container { width: 100%; max-width: 450px; background: white; padding: 25px; border-radius: 24px; box-shadow: 0 12px 30px rgba(0,0,0,0.1); }
        h2 { text-align: center; color: var(--primary); margin-top: 0; }
        
        #drop-area { 
            border: 2px dashed #cbd5e0; padding: 50px 20px; text-align: center; border-radius: 20px; 
            cursor: not-allowed; transition: 0.3s; display: block; background: #fafafa; margin-bottom: 20px;
            opacity: 0.5;
        }
        #drop-area.ready { border-color: var(--primary); background: #fff; cursor: pointer; opacity: 1; }
        #drop-area.highlight { background: #f0f7ff; border-style: solid; }

        .status-badge { display: inline-block; padding: 6px 16px; border-radius: 20px; font-size: 0.85em; background: #eee; margin-bottom: 15px; font-weight: bold; }
        .status-online { background: #e6fffa; color: #2c7a7b; }
        .status-ready { background: #007bff; color: white; }
        
        .peer-info { font-size: 0.9em; color: #4a5568; margin: 10px 0; padding: 12px; background: #edf2f7; border-radius: 12px; display: none; }
        .progress-container { width: 100%; background: #edf2f7; height: 10px; border-radius: 5px; overflow: hidden; display: none; margin: 20px 0; }
        #progress { width: 0%; height: 100%; background: var(--success); }
        
        .file-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; background: #fff; border: 1px solid #edf2f7; border-radius: 12px; margin-bottom: 10px; }
        .file-name { font-size: 0.9em; word-break: break-all; margin-right: 10px; flex: 1; }
        .badge-info { font-size: 0.75em; padding: 4px 10px; border-radius: 10px; background: #eee; }
        
        .btn-download { 
            background: var(--success); color: white; text-decoration: none; 
            padding: 8px 15px; border-radius: 8px; font-size: 0.85em; font-weight: bold;
            display: inline-block; text-align: center;
        }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div class="container">
    <h2>ğŸš€ AirDrop</h2>
    <div style="text-align: center;">
        <span id="status" class="status-badge">ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šä¸­...</span>
        <div id="peer-info" class="peer-info">ğŸ“ æ¥ç¶šç›¸æ‰‹: <span id="peer-id">å¾…æ©Ÿä¸­...</span></div>
    </div>

    <label id="drop-area">
        <input type="file" id="fileInput" multiple disabled>
        <strong id="drop-text">ç›¸æ‰‹ã®æ¥ç¶šã‚’å¾…æ©Ÿä¸­...</strong><br>
        <span id="drop-subtext" style="color: #718096; font-size: 0.8em;">åŒã˜Wi-Fiã®ãƒ‡ãƒã‚¤ã‚¹ã§é–‹ã„ã¦ãã ã•ã„</span>
    </label>

    <div class="progress-container" id="p-container"><div id="progress"></div></div>
    <div id="file-list"></div>
</div>

<script>
    const socket = io({ transports: ['websocket'] });
    const status = document.getElementById('status');
    const dropArea = document.getElementById('drop-area');
    const dropText = document.getElementById('drop-text');
    const fileInput = document.getElementById('fileInput');
    const progress = document.getElementById('progress');
    const pContainer = document.getElementById('p-container');
    const fileList = document.getElementById('file-list');
    const peerInfo = document.getElementById('peer-info');

    let peerConnection, dataChannel, targetPeerSid = null, receivedChunks = [], currentMetadata = null;
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] };

    function setReady(isReady, sid = null) {
        if (isReady) {
            targetPeerSid = sid;
            dropArea.classList.add('ready');
            fileInput.disabled = false;
            dropText.innerText = "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ";
            status.innerText = "ğŸ‘¥ æ¥ç¶šå®Œäº†";
            status.classList.add('status-ready');
            peerInfo.style.display = 'block';
        } else {
            targetPeerSid = null;
            dropArea.classList.remove('ready');
            fileInput.disabled = true;
            dropText.innerText = "ç›¸æ‰‹ã®æ¥ç¶šã‚’å¾…æ©Ÿä¸­...";
            status.innerText = "âœ… ã‚ªãƒ³ãƒ©ã‚¤ãƒ³";
            status.classList.remove('status-ready');
        }
    }

    socket.on('connect', () => { status.innerText = "âœ… ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šå®Œäº†"; status.classList.add('status-online'); });
    socket.on('peer_joined', (data) => { setReady(true, data.id); socket.emit('message', { type: 'ping', to: data.id }); });

    socket.on('message', async data => {
        const fromSid = data.from_sid;
        if (data.type === 'ping') return setReady(true, fromSid);
        
        if (data.type === 'offer') {
            initPeer(false, fromSid);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('message', { type: 'answer', sdp: answer, to: fromSid });
        } else if (data.type === 'answer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        } else if (data.type === 'candidate') {
            if (peerConnection) await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
    });

    function initPeer(isOffer, targetSid) {
        if (peerConnection) return;
        peerConnection = new RTCPeerConnection(rtcConfig);
        peerConnection.onicecandidate = e => {
            if (e.candidate) socket.emit('message', { type: 'candidate', candidate: e.candidate, to: targetSid });
        };
        if (isOffer) {
            dataChannel = peerConnection.createDataChannel("fileTransfer", { ordered: true });
            setupDataChannel(dataChannel);
        } else {
            peerConnection.ondatachannel = e => setupDataChannel(e.channel);
        }
    }

    function setupDataChannel(channel) {
        channel.onopen = () => { status.innerText = "âš¡ P2Pãƒªãƒ³ã‚¯ç¢ºç«‹ï¼"; status.style.background = "#28a745"; };
        channel.onclose = () => setReady(false);
        channel.onmessage = (e) => {
            if (typeof e.data === 'string') {
                const msg = JSON.parse(e.data);
                if (msg.type === 'metadata') { currentMetadata = msg; receivedChunks = []; pContainer.style.display = 'block'; }
                else if (msg.type === 'eof') { saveFile(); pContainer.style.display = 'none'; progress.style.width = '0%'; }
            } else {
                receivedChunks.push(e.data);
                if (currentMetadata) {
                    const currentSize = receivedChunks.reduce((a, c) => a + c.byteLength, 0);
                    progress.style.width = (currentSize / currentMetadata.size * 100) + '%';
                }
            }
        };
    }

    fileInput.onchange = async () => {
        if (!targetPeerSid || fileInput.disabled) return;
        initPeer(true, targetPeerSid);
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('message', { type: 'offer', sdp: offer, to: targetPeerSid });

        const checkInterval = setInterval(async () => {
            if (dataChannel?.readyState === 'open') {
                clearInterval(checkInterval);
                pContainer.style.display = 'block';
                for (let f of fileInput.files) {
                    const item = addSentFileStatus(f.name);
                    await sendFile(f, item);
                }
                pContainer.style.display = 'none';
                fileInput.value = "";
                status.innerText = "âœ… é€ä¿¡å®Œäº†";
            }
        }, 1000);
    };

    function addSentFileStatus(name) {
        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `<span class="file-name">${name}</span><span class="badge-info">é€ä¿¡ä¸­...</span>`;
        fileList.prepend(item);
        return item;
    }

    async function sendFile(file, item) {
        return new Promise(resolve => {
            dataChannel.send(JSON.stringify({ type: 'metadata', name: file.name, size: file.size }));
            const reader = new FileReader();
            let offset = 0, chunkSize = 16384;
            reader.onload = e => {
                dataChannel.send(e.target.result);
                offset += e.target.result.byteLength;
                progress.style.width = (offset / file.size * 100) + '%';
                if (offset < file.size) read();
                else {
                    dataChannel.send(JSON.stringify({ type: 'eof' }));
                    item.querySelector('.badge-info').innerText = "å®Œäº† âœ…";
                    setTimeout(resolve, 500);
                }
            };
            const read = () => reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
            read();
        });
    }

    function saveFile() {
        if (!currentMetadata || receivedChunks.length === 0) return;
        const blob = new Blob(receivedChunks, { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const name = currentMetadata.name;

        const item = document.createElement('div');
        item.className = 'file-item';
        item.innerHTML = `
            <span class="file-name">${name}</span>
            <a href="${url}" download="${name}" target="_blank" class="btn-download">ä¿å­˜</a>
        `;
        fileList.prepend(item);

        // Viaå¯¾ç­–: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒœã‚¿ãƒ³ã‚’ã€Œæ‰‹å‹•ã§ã€æŠ¼ã•ã›ã‚‹ã®ãŒæœ€ã‚‚ç¢ºå®Ÿã§ã™ãŒã€è‡ªå‹•ã‚¯ãƒªãƒƒã‚¯ã‚‚è©¦ã¿ã¾ã™
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        a.style.display = 'none';
        document.body.appendChild(a);
        setTimeout(() => {
            try { a.click(); } catch(e) {}
            document.body.removeChild(a);
        }, 100);

        // Viaãªã©ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ã™ãã«URLã‚’ç ´æ£„ã™ã‚‹ã¨ä¿å­˜ã«å¤±æ•—ã™ã‚‹ãŸã‚ã€3åˆ†é–“ç¶­æŒã—ã¾ã™
        setTimeout(() => URL.revokeObjectURL(url), 180000);
    }
</script>
</body>
</html>