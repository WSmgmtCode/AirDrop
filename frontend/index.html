<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirDrop</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.3/StreamSaver.min.js"></script>
    <style>
        :root { --primary: #007bff; --success: #28a745; --danger: #dc3545; --bg: #f0f2f5; }
        * { box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); margin: 0; padding: 10px; display: flex; justify-content: center; min-height: 100vh; }
        .container { width: 100%; max-width: 400px; background: white; padding: 20px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 15px; height: fit-content; }
        h2 { text-align: center; color: var(--primary); margin: 0; font-size: 1.4em; }
        
        .status-box { text-align: center; padding: 12px; border-radius: 12px; background: #f8f9fa; border: 1px solid #eee; min-height: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; }
        .status-badge { font-size: 0.85em; font-weight: bold; color: #666; }
        .status-ready { color: var(--success); }
        .stats-detail { font-size: 0.7em; color: #888; display: flex; gap: 8px; font-family: monospace; }

        #qr-section { background: #fff; border: 1px solid #eee; border-radius: 15px; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #qrcode { line-height: 0; background: #fff; padding: 5px; }

        #drop-area { border: 2px dashed #cbd5e0; padding: 25px 10px; text-align: center; border-radius: 15px; cursor: not-allowed; background: #fafafa; opacity: 0.5; transition: 0.3s; display: flex; flex-direction: column; gap: 5px; }
        #drop-area.ready { border-color: var(--primary); background: #fff; cursor: pointer; opacity: 1; }
        .limit-note { font-size: 0.7em; color: var(--danger); background: #fff5f5; padding: 8px; border-radius: 8px; border: 1px solid #feb2b2; margin-top: 5px; display: none; }

        .progress-wrapper { display: none; align-items: center; gap: 10px; margin: 10px 0; }
        .progress-container { flex: 1; background: #eee; height: 14px; border-radius: 7px; overflow: hidden; }
        #progress { width: 0%; height: 100%; background: var(--success); transition: width 0.1s linear; }
        
        .btn-cancel { background: var(--danger); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.75em; font-weight: bold; cursor: pointer; flex-shrink: 0; }

        #file-list { display: flex; flex-direction: column; gap: 8px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f8f9fa; border: 1px solid #eee; border-radius: 10px; }
        .file-info { display: flex; flex-direction: column; flex: 1; overflow: hidden; margin-right: 10px; }
        .file-name { font-size: 0.75em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .file-meta { font-size: 0.65em; color: #888; }
        .status-tag { font-size: 0.7em; font-weight: bold; padding: 4px 8px; border-radius: 4px; }
        .tag-sent { background: #e6f4ea; color: var(--success); }
        .tag-received { background: #e8f0fe; color: var(--primary); }
        .btn-download { background: var(--success); color: white; text-decoration: none; padding: 5px 12px; border-radius: 6px; font-size: 0.75em; font-weight: bold; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div class="container">
    <h2>ğŸš€ AirDrop</h2>
    <div class="status-box">
        <span id="status" class="status-badge">ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šå¾…æ©Ÿä¸­...</span>
        <div id="stats-info" class="stats-detail" style="display: none;">
            <span id="conn-type">Type: ---</span>
            <span id="bitrate">0.00 Mbps</span>
        </div>
    </div>
    
    <div id="qr-section">
        <div id="qrcode"></div>
        <div style="font-size:0.75em; color:#666; font-weight:bold;">ğŸ“± ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦æ¥ç¶š</div>
    </div>

    <label id="drop-area">
        <input type="file" id="fileInput" multiple disabled>
        <strong id="drop-text">æ¥ç¶šç›¸æ‰‹ã‚’æ¢ã—ã¦ã„ã¾ã™</strong>
        <div id="limit-info" class="limit-note">âš ï¸ 100MBè¶…ã¯ Chrome/Safari æ¨å¥¨</div>
    </label>

    <div class="progress-wrapper" id="p-wrapper">
        <div class="progress-container"><div id="progress"></div></div>
        <button id="cancelBtn" class="btn-cancel">ä¸­æ­¢</button>
    </div>

    <div id="file-list"></div>
</div>

<script>
    const socket = io({ transports: ['websocket'] });
    const status = document.getElementById('status'), qrSection = document.getElementById('qr-section');
    const dropArea = document.getElementById('drop-area'), fileInput = document.getElementById('fileInput');
    const progress = document.getElementById('progress'), pWrapper = document.getElementById('p-wrapper');
    const fileList = document.getElementById('file-list'), cancelBtn = document.getElementById('cancelBtn');
    const statsInfo = document.getElementById('stats-info'), connTypeLabel = document.getElementById('conn-type'), bitrateLabel = document.getElementById('bitrate');

    let peerConnection, dataChannel, targetPeerSid = null;
    let fileWriter = null, receivedChunks = [], currentMetadata = null, receivedSize = 0;
    let isCancelled = false;
    let lastBytes = 0, statsInterval = null;
    const BIG_FILE_LIMIT = 100 * 1024 * 1024;

    new QRCode(document.getElementById("qrcode"), { text: window.location.href, width: 120, height: 120 });

    function startConnection(sid) {
        if (targetPeerSid || peerConnection) return;
        targetPeerSid = sid; status.innerText = "â³ P2Pãƒªãƒ³ã‚¯è¨­å®šä¸­...";
        initPeer(true, sid);
    }

    socket.on('peer_joined', data => startConnection(data.id));
    socket.on('message', async data => {
        const fromSid = data.from_sid;
        if (data.type === 'ping') return startConnection(fromSid);
        if (data.type === 'offer') {
            if (peerConnection && peerConnection.signalingState !== 'stable') return;
            initPeer(false, fromSid);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('message', { type: 'answer', sdp: answer, to: fromSid });
        } else if (data.type === 'answer' && peerConnection?.signalingState === 'have-local-offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        } else if (data.type === 'candidate' && peerConnection?.remoteDescription) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.warn(e));
        }
    });

    function initPeer(isOffer, targetSid) {
        if (peerConnection) return;
        peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        peerConnection.onicecandidate = e => e.candidate && socket.emit('message', { type: 'candidate', candidate: e.candidate, to: targetSid });

        if (isOffer) {
            dataChannel = peerConnection.createDataChannel("fileTransfer", { ordered: true });
            setupDataChannel(dataChannel);
            peerConnection.createOffer().then(offer => peerConnection.setLocalDescription(offer))
                .then(() => socket.emit('message', { type: 'offer', sdp: peerConnection.localDescription, to: targetSid }));
        } else {
            peerConnection.ondatachannel = e => setupDataChannel(e.channel);
        }
    }

    function setupDataChannel(channel) {
        dataChannel = channel;
        dataChannel.bufferedAmountLowThreshold = 512 * 1024;
        channel.onopen = () => {
            qrSection.style.display = 'none'; dropArea.classList.add('ready');
            fileInput.disabled = false; document.getElementById('limit-info').style.display = 'block';
            document.getElementById('drop-text').innerText = "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ";
            status.innerText = "âš¡ æ¥ç¶šå®Œäº†ï¼"; status.classList.add('status-ready');
            startStatsMonitor();
        };

        channel.onmessage = async e => {
            if (typeof e.data === 'string') {
                const msg = JSON.parse(e.data);
                if (msg.type === 'metadata') {
                    currentMetadata = msg; receivedSize = 0; receivedChunks = [];
                    pWrapper.style.display = 'flex';
                    if (msg.size > BIG_FILE_LIMIT) {
                        fileWriter = streamSaver.createWriteStream(msg.name, { size: msg.size }).getWriter();
                    }
                } else if (msg.type === 'eof') { await finalizeFile(); }
                else if (msg.type === 'cancel') { alert("ç›¸æ‰‹ãŒä¸­æ–­ã—ã¾ã—ãŸ"); location.reload(); }
            } else {
                if (fileWriter) await fileWriter.write(new Uint8Array(e.data));
                else receivedChunks.push(e.data);
                receivedSize += e.data.byteLength;
                progress.style.width = (receivedSize / currentMetadata.size * 100) + '%';
            }
        };
    }

    function startStatsMonitor() {
        statsInfo.style.display = 'flex';
        statsInterval = setInterval(async () => {
            if (!peerConnection) return;
            const stats = await peerConnection.getStats();
            stats.forEach(report => {
                // æ¥ç¶šã‚¿ã‚¤ãƒ—ã®å–å¾—
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    const localCand = stats.get(report.localCandidateId);
                    const typeMap = { host: 'ãƒ­ãƒ¼ã‚«ãƒ«', srflx: 'ç›´æ¥(P2P)', relay: 'ä¸­ç¶™', prflx: 'ç›´æ¥(P2P)' };
                    connTypeLabel.innerText = `æ¥ç¶š: ${typeMap[localCand.candidateType] || localCand.candidateType}`;
                }
                // è»¢é€é€Ÿåº¦ã®è¨ˆç®— (DataChannelçµŒç”±ã®åˆè¨ˆ)
                if (report.type === 'data-channel') {
                    const bytes = report.bytesSent + report.bytesReceived;
                    const mbps = (((bytes - lastBytes) * 8) / (1024 * 1024)).toFixed(2);
                    bitrateLabel.innerText = `${mbps} Mbps`;
                    lastBytes = bytes;
                }
            });
        }, 1000);
    }

    async function finalizeFile() {
        pWrapper.style.display = 'none';
        const name = currentMetadata.name;
        const size = (currentMetadata.size / (1024*1024)).toFixed(1) + "MB";
        let url = null;
        if (fileWriter) { await fileWriter.close(); fileWriter = null; } 
        else {
            const blob = new Blob(receivedChunks);
            url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = name; a.click();
        }
        addFileListUI(name, size, url, false);
    }

    function addFileListUI(name, size, url, isSender) {
        const item = document.createElement('div');
        item.className = 'file-item';
        const statusHtml = isSender ? 
            `<span class="status-tag tag-sent">âœ“ é€ä¿¡æ¸ˆã¿</span>` : 
            `<div style="display:flex; align-items:center; gap:5px;"><span class="status-tag tag-received">âœ“ å—ä¿¡æ¸ˆ</span>
             <a href="${url || '#'}" ${url ? `download="${name}"` : 'onclick="alert(\'å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä¿å­˜æ¸ˆã¿ã§ã™\')"'} class="btn-download">å†ä¿å­˜</a></div>`;

        item.innerHTML = `<div class="file-info"><span class="file-name">${name}</span><span class="file-meta">${size}</span></div>${statusHtml}`;
        fileList.prepend(item);
    }

    cancelBtn.onclick = () => {
        if (!confirm("è»¢é€ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ")) return;
        isCancelled = true;
        if (dataChannel?.readyState === 'open') dataChannel.send(JSON.stringify({ type: 'cancel' }));
        setTimeout(() => location.reload(), 500);
    };

    fileInput.onchange = async () => {
        if (dataChannel?.readyState !== 'open') return;
        pWrapper.style.display = 'flex';
        isCancelled = false;
        for (let f of fileInput.files) {
            if (isCancelled) break;
            await sendFile(f);
            addFileListUI(f.name, (f.size / (1024*1024)).toFixed(1) + "MB", null, true);
        }
        pWrapper.style.display = 'none';
        fileInput.value = "";
    };

    async function sendFile(file) {
        return new Promise(resolve => {
            dataChannel.send(JSON.stringify({ type: 'metadata', name: file.name, size: file.size }));
            const reader = new FileReader();
            let offset = 0, chunkSize = 16384 * 4, bufferThreshold = 1024 * 1024;
            const readNext = () => {
                if (isCancelled) return resolve();
                if (offset < file.size) {
                    if (dataChannel.bufferedAmount > bufferThreshold) {
                        dataChannel.onbufferedamountlow = () => { dataChannel.onbufferedamountlow = null; readNext(); };
                        return;
                    }
                    reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
                } else {
                    dataChannel.send(JSON.stringify({ type: 'eof' }));
                    setTimeout(resolve, 500);
                }
            };
            reader.onload = e => {
                try { 
                    dataChannel.send(e.target.result); 
                    offset += e.target.result.byteLength;
                    progress.style.width = (offset / file.size * 100) + '%'; 
                    readNext();
                } catch (err) { setTimeout(readNext, 100); }
            };
            readNext();
        });
    }
</script>
</body>
</html>