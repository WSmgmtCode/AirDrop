<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirDrop</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.3/StreamSaver.min.js"></script>
    <style>
        :root { --primary: #007bff; --success: #28a745; --danger: #dc3545; --bg: #f0f2f5; }
        * { box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); margin: 0; padding: 10px; display: flex; justify-content: center; min-height: 100vh; }
        .container { width: 100%; max-width: 400px; background: white; padding: 20px; border-radius: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 15px; height: fit-content; }
        h2 { text-align: center; color: var(--primary); margin: 0; font-size: 1.4em; }
        
        .status-box { text-align: center; padding: 12px; border-radius: 12px; background: #f8f9fa; border: 1px solid #eee; min-height: 50px; display: flex; align-items: center; justify-content: center; }
        .status-badge { font-size: 0.85em; font-weight: bold; color: #666; }
        .status-ready { color: var(--success); }

        #qr-section { background: #fff; border: 1px solid #eee; border-radius: 15px; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #qrcode { line-height: 0; background: #fff; padding: 5px; }

        #drop-area { border: 2px dashed #cbd5e0; padding: 25px 10px; text-align: center; border-radius: 15px; cursor: not-allowed; background: #fafafa; opacity: 0.5; transition: 0.3s; display: flex; flex-direction: column; gap: 5px; }
        #drop-area.ready { border-color: var(--primary); background: #fff; cursor: pointer; opacity: 1; }
        .limit-note { font-size: 0.7em; color: var(--danger); background: #fff5f5; padding: 8px; border-radius: 8px; border: 1px solid #feb2b2; margin-top: 5px; display: none; }

        .progress-wrapper { display: none; align-items: center; gap: 10px; margin: 10px 0; }
        .progress-container { flex: 1; background: #eee; height: 14px; border-radius: 7px; overflow: hidden; }
        #progress { width: 0%; height: 100%; background: var(--success); transition: width 0.1s linear; }
        
        .btn-cancel { background: var(--danger); color: white; border: none; padding: 6px 12px; border-radius: 6px; font-size: 0.75em; font-weight: bold; cursor: pointer; flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        #file-list { display: flex; flex-direction: column; gap: 8px; }
        .file-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f8f9fa; border: 1px solid #eee; border-radius: 10px; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
        
        .file-info { display: flex; flex-direction: column; flex: 1; overflow: hidden; margin-right: 10px; }
        .file-name { font-size: 0.75em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .file-meta { font-size: 0.65em; color: #888; }
        
        .status-tag { font-size: 0.7em; font-weight: bold; padding: 4px 8px; border-radius: 4px; display: flex; align-items: center; gap: 3px; }
        .tag-sent { background: #e6f4ea; color: var(--success); }
        .tag-received { background: #e8f0fe; color: var(--primary); }
        
        .btn-download { background: var(--success); color: white; text-decoration: none; padding: 5px 12px; border-radius: 6px; font-size: 0.75em; font-weight: bold; }
        
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div class="container">
    <h2>üöÄ AirDrop</h2>
    <div class="status-box"><span id="status" class="status-badge">„Çµ„Éº„Éê„ÉºÊé•Á∂öÂæÖÊ©ü‰∏≠...</span></div>
    
    <div id="qr-section">
        <div id="qrcode"></div>
        <div style="font-size:0.75em; color:#666; font-weight:bold;">üì± „Çπ„Ç≠„É£„É≥„Åó„Å¶Êé•Á∂ö</div>
    </div>

    <label id="drop-area">
        <input type="file" id="fileInput" multiple disabled>
        <strong id="drop-text">Êé•Á∂öÁõ∏Êâã„ÇíÊé¢„Åó„Å¶„ÅÑ„Åæ„Åô</strong>
        <div id="limit-info" class="limit-note">‚ö†Ô∏è 100MBË∂Ö„ÅØ Chrome/Safari Êé®Â•®</div>
    </label>

    <div class="progress-wrapper" id="p-wrapper">
        <div class="progress-container"><div id="progress"></div></div>
        <button id="cancelBtn" class="btn-cancel">‰∏≠Ê≠¢</button>
    </div>

    <div id="file-list"></div>
</div>

<script>
    const socket = io({ transports: ['websocket'] });
    const status = document.getElementById('status'), qrSection = document.getElementById('qr-section');
    const dropArea = document.getElementById('drop-area'), fileInput = document.getElementById('fileInput');
    const progress = document.getElementById('progress'), pWrapper = document.getElementById('p-wrapper');
    const fileList = document.getElementById('file-list'), cancelBtn = document.getElementById('cancelBtn');

    let peerConnection, dataChannel, targetPeerSid = null;
    let fileWriter = null, receivedChunks = [], currentMetadata = null, receivedSize = 0;
    let isCancelled = false;
    const BIG_FILE_LIMIT = 100 * 1024 * 1024;

    new QRCode(document.getElementById("qrcode"), { text: window.location.href, width: 120, height: 120 });

    function startConnection(sid) {
        if (targetPeerSid || peerConnection) return;
        targetPeerSid = sid; status.innerText = "‚è≥ P2P„É™„É≥„ÇØË®≠ÂÆö‰∏≠...";
        initPeer(true, sid);
    }

    socket.on('peer_joined', data => startConnection(data.id));
    socket.on('message', async data => {
        const fromSid = data.from_sid;
        if (data.type === 'ping') return startConnection(fromSid);
        if (data.type === 'offer') {
            if (peerConnection && peerConnection.signalingState !== 'stable') return;
            initPeer(false, fromSid);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            socket.emit('message', { type: 'answer', sdp: answer, to: fromSid });
        } else if (data.type === 'answer' && peerConnection?.signalingState === 'have-local-offer') {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        } else if (data.type === 'candidate' && peerConnection?.remoteDescription) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.warn(e));
        }
    });

    function initPeer(isOffer, targetSid) {
        if (peerConnection) return;
        peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        peerConnection.onicecandidate = e => e.candidate && socket.emit('message', { type: 'candidate', candidate: e.candidate, to: targetSid });

        if (isOffer) {
            dataChannel = peerConnection.createDataChannel("fileTransfer", { ordered: true });
            setupDataChannel(dataChannel);
            peerConnection.createOffer().then(offer => peerConnection.setLocalDescription(offer))
                .then(() => socket.emit('message', { type: 'offer', sdp: peerConnection.localDescription, to: targetSid }));
        } else {
            peerConnection.ondatachannel = e => setupDataChannel(e.channel);
        }
    }

    function setupDataChannel(channel) {
        dataChannel = channel;
        dataChannel.bufferedAmountLowThreshold = 512 * 1024;
        channel.onopen = () => {
            qrSection.style.display = 'none'; dropArea.classList.add('ready');
            fileInput.disabled = false; document.getElementById('limit-info').style.display = 'block';
            document.getElementById('drop-text').innerText = "„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû";
            status.innerText = "‚ö° Êé•Á∂öÂÆå‰∫ÜÔºÅ"; status.classList.add('status-ready');
        };

        channel.onmessage = async e => {
            if (typeof e.data === 'string') {
                const msg = JSON.parse(e.data);
                if (msg.type === 'metadata') {
                    currentMetadata = msg; receivedSize = 0; receivedChunks = [];
                    pWrapper.style.display = 'flex';
                    if (msg.size > BIG_FILE_LIMIT) {
                        fileWriter = streamSaver.createWriteStream(msg.name, { size: msg.size }).getWriter();
                    }
                } else if (msg.type === 'eof') { await finalizeFile(); }
                else if (msg.type === 'cancel') { alert("Áõ∏Êâã„Åå‰∏≠Êñ≠„Åó„Åæ„Åó„Åü"); location.reload(); }
            } else {
                if (fileWriter) await fileWriter.write(new Uint8Array(e.data));
                else receivedChunks.push(e.data);
                receivedSize += e.data.byteLength;
                progress.style.width = (receivedSize / currentMetadata.size * 100) + '%';
            }
        };
    }

    async function finalizeFile() {
        pWrapper.style.display = 'none';
        const name = currentMetadata.name;
        const size = (currentMetadata.size / (1024*1024)).toFixed(1) + "MB";
        let url = null;
        if (fileWriter) { await fileWriter.close(); fileWriter = null; } 
        else {
            const blob = new Blob(receivedChunks);
            url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = name; a.click();
        }
        addFileListUI(name, size, url, false);
    }

    function addFileListUI(name, size, url, isSender) {
        const item = document.createElement('div');
        item.className = 'file-item';
        const statusHtml = isSender ? 
            `<span class="status-tag tag-sent">‚úì ÈÄÅ‰ø°Ê∏à„Åø</span>` : 
            `<div style="display:flex; align-items:center; gap:5px;"><span class="status-tag tag-received">‚úì Âèó‰ø°Ê∏à</span>
             <a href="${url || '#'}" ${url ? `download="${name}"` : 'onclick="alert(\'Â§ßÂÆπÈáè„Éï„Ç°„Ç§„É´„ÅØ„Éï„Ç©„É´„ÉÄ„ÇíÁ¢∫Ë™ç\')"'} class="btn-download">ÂÜç‰øùÂ≠ò</a></div>`;

        item.innerHTML = `
            <div class="file-info">
                <span class="file-name">${name}</span>
                <span class="file-meta">${size}</span>
            </div>
            ${statusHtml}`;
        fileList.prepend(item);
    }

    cancelBtn.onclick = () => {
        if (!confirm("Ëª¢ÈÄÅ„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÅãÔºü")) return;
        isCancelled = true;
        if (dataChannel?.readyState === 'open') dataChannel.send(JSON.stringify({ type: 'cancel' }));
        setTimeout(() => location.reload(), 500);
    };

    fileInput.onchange = async () => {
        if (dataChannel?.readyState !== 'open') return;
        pWrapper.style.display = 'flex';
        isCancelled = false;
        for (let f of fileInput.files) {
            if (isCancelled) break;
            await sendFile(f);
            // ÈÄÅ‰ø°ÂÆå‰∫ÜÂæå„Å´„É™„Çπ„Éà„Å´ËøΩÂä†
            addFileListUI(f.name, (f.size / (1024*1024)).toFixed(1) + "MB", null, true);
        }
        pWrapper.style.display = 'none';
        fileInput.value = "";
    };

    async function sendFile(file) {
        return new Promise(resolve => {
            dataChannel.send(JSON.stringify({ type: 'metadata', name: file.name, size: file.size }));
            const reader = new FileReader();
            let offset = 0, chunkSize = 16384 * 4, bufferThreshold = 1024 * 1024;
            const readNext = () => {
                if (isCancelled) return resolve();
                if (offset < file.size) {
                    if (dataChannel.bufferedAmount > bufferThreshold) {
                        dataChannel.onbufferedamountlow = () => { dataChannel.onbufferedamountlow = null; readNext(); };
                        return;
                    }
                    reader.readAsArrayBuffer(file.slice(offset, offset + chunkSize));
                } else {
                    dataChannel.send(JSON.stringify({ type: 'eof' }));
                    setTimeout(resolve, 500);
                }
            };
            reader.onload = e => {
                try { dataChannel.send(e.target.result); offset += e.target.result.byteLength;
                    progress.style.width = (offset / file.size * 100) + '%'; readNext();
                } catch (err) { setTimeout(readNext, 100); }
            };
            readNext();
        });
    }
</script>
</body>
</html>